\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{setspace}



\title{Tasks}
\author{Phil Reinartz}
\date{00.00.0000}

\begin{document}

\maketitle

\section{Task 1 Stages of the compilation)}

\textbf{First stage "Preprocessing"} The main function of the preprocessor is, that it adds the "full" c code into your .i data. For example, the stdio.h librarie is nothing other than some fuctions that someone declared, so that you don't have to write them yourself. These functions are loaded by the preprocessor in your programm, because you wrote \#include <stdio.h> inside your code. The same is also for makros that you have placed. For example: if you wrote "\#define Maximalwert 1234567890987654321234567899999999", the preprocessor takes the value of Maximalwert and puts it everywhere in the programm where you wrote Maximalwert. So all in all, the preprocessor does nothing other, than complete your programm by replacing predefined makros with the right value and adding and suptracting content you want to include, or your machine needs to work right.
So that your programm is ready to be compiled in the next step.

\singlespacing

\textbf{Second stage, the compilation to assembly} The next part of the compilation is the part where the most work gets done. In the first step, your preprocessor did necessary replacements for you, to make your .c script ready to be compiled. Now the compiler has to create a file, that your machine is able to process. The first step of this process is, to create assembly instructions of the preprocessors revised c code. The assembly instructions are a "humanoid" version of the binary, that is in some context also textbased, but on a very low leveltextbased. The now created .s file is fuction wise the equivalent of your .i file written in assembly. For example: the assembly instruction  "movl    \$0, \%eax" is the equivalent of setting the return value of your function by zero.

\singlespacing

\textbf{Third stage, creating the objectfile}The object file is an interessting part of the compilation that is a easy to understand process, but not an easy to understand file. The object file is basically the functional equivalent of your assembly instructions, but written in machine language(not the full binary, but also writen with 0s and 1s). The .o file is hard to read, because you have to translate every line of code with the manual of your processor, because the binary language is architecture dependend. If you work with several different processors, this could get very complicated very quickly.

\singlespacing

\textbf{Final stage, linking your .o file.} The final step of your compilation is, that your script needs somehow to be executable. This is done at the linking Stage, which works kind of similar to the preprocessing staged (don't get me wrong, it's definetelly not the same or similar thing, but the basic idea is similar). The linker is necessary, to define everything, that is still undefined, which could be for example some kind of machine specific function that needs to be declared. Otherwise, your machine probably wouldn't know what to do at the part where the function is used, because the machine has not the abillity to process other things than basic commands. So the linker replaces "more complex" functions with the address to the  basic commands that describe the used function. This turns your file into an executable, that has several connections to many other .o files, that do nothing other, than describing functions of your .o file into processor understandable commands.

\section{1.3)}

\textbf{Answer:} Hpjhnefoisjhblsjhnbvosjhbvls,jhb
\end{document}
